# Copyright (C) 2014  Vangelis Tasoulas <vangelis@tasoulas.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import traceback
from libs.helperfuncs import *
from libs.collector import DataCollector
from collections import OrderedDict
import os
import glob
import threading
import thread

########################################################################
class external_plugins(DataCollector):
    """
    Read the output generated by *any* external (python or non-python) script.
    The external script should print the collected values to the standard output
    (STDOUT).
    The only downside is that prevResults cannot be passed back to the external
    plugins so additional calculations (if needed) will have to be post processed.

    One pair of header/value per line should be printed in STDOUT by the external
    plugins as in the following example:

    header1 value1
    header2 value2
    header3 value3

    The eventual result will be parsed by the plugin, in the format accepted by
    sysdata-collector python plugins as follows:

    sample['header1'] = 'value1'
    sample['header2'] = 'value2'
    sample['header3'] = 'value3'
    """

    # Used for thread locking
    LOCK = threading.Lock()
    external_plugins_list = []
    header_prepend_plugin_name = True

    #----------------------------------------------------------------------
    def readConfigVars(self):
        """
        TODO:
        Read the external_plugin_locations (default should load any file with the given extensions
        from the active-plugin folder), header_prepend_plugin_name and load_extensions (different script
        extensions to be loaded) from the configuration file
        """
        external_plugins_path = '/home/cyber/Dropbox/Various/Scripts/Python/sysdata-collector/active-plugins'

        if(os.path.exists(external_plugins_path)):
            self.external_plugins_list = glob.glob(external_plugins_path + "/*.sh")

    #----------------------------------------------------------------------
    def collect(self, prevResults = None):
        """
        Very simple plugin which parses the uptime from /proc/uptime,
        by using a regular expression.

        Check the CPU plugin for a more advanced starting point.
        """

        samples = OrderedDict()
        threads = {}
        try:
            for external_plugin in self.external_plugins_list:
                # Collect data from each external plugin in a separate thread
                threads[external_plugin] = threading.Thread(target=self.runCollectThreaded, args=(samples, external_plugin))
                threads[external_plugin].start()

            for external_plugin in self.external_plugins_list:
                # Wait for all of the threads to finish execution
                threads[external_plugin].join()
                del threads[external_plugin]
        except:
            traceback.print_exc()
            exit(1)

        return samples

    def runCollectThreaded(self, result, externalScriptPath):
        """
        Function ro run the collect jobs in threads.
        toRun:        The plugin to be executed
        results:      The dictionary to store the result
        key:          The key in dict results to store the result
        prevResults:  The previous results of this plugin
        """

        # Execute the script
        cmd = executeCommand([externalScriptPath])

        # Check if the return code is zero (which means that the script was executed successfully)
        if (cmd.getReturnCode() != 0):
            LOG.critical("Execution return code of the external script '" + externalScriptPath + "' is '" + str(cmd.getReturnCode()) + "'")
            LOG.critical("Please check what went wrong with the script. Aborting execution.")
            thread.interrupt_main()


        # Get the basename of the script without the extension
        name = os.path.basename(os.path.splitext(externalScriptPath)[0])

        r = quick_regexp()
        for line in cmd.getStdout().split('\n'):
            # Each line should have two space separated values.
            # First is the header and second is the actual value
            if(r.search('(\S+)\s+(\S+)', line)):

                if self.header_prepend_plugin_name:
                    # In the header, prepend the name of the script to avoid conficts
                    header = "{0}_{1}".format(name, r.groups[0])
                else:
                    header = r.groups[0]
                value = r.groups[1]

                with self.LOCK:
                    #print "'" + name + "' ('" + threading.current_thread().name + "') acquired lock"
                    # If the header exists, rais an error and exit.
                    if result.has_key(header):
                        LOG.critical("Header '" + header + "' which is generated by script '" + externalScriptPath + "' already exists!!")
                        LOG.critical("Please check that your external scripts have different basenames and/or headers. Aborting execution.")
                        thread.interrupt_main()
                        #os._exit(1)
                    result[header] = value
