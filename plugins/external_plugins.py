# Copyright (C) 2014  Vangelis Tasoulas <vangelis@tasoulas.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import traceback
from libs.helperfuncs import *
from libs.collector import DataCollector
from collections import OrderedDict
import os
import glob
import threading
import thread
from libs.globalvars import active_plugins_dir

########################################################################
class external_plugins(DataCollector):
    """
    Read the output generated by *any* external non-python plugins/scripts.
    The external scripts should be placed in the active-plugins folder (it
    doesn't matter if they are symbolic links or not, in contrary to the
    way of handling the standard python plugins).
    The collected values should be printed to the standard output (STDOUT)
    and the plugin should have an exit status value of 0 (successfully executed).

    The only disadvantage of writing external scripts is that 'prevResults' cannot
    be passed back to the plugin, so additional calculations (if needed) based on
    results collected in the previous run will have to be post processed.

    One pair of header/value per line should be printed in STDOUT by the external
    plugins as in the following example:

    header1 value1
    header2 value2
    header3 value3

    The eventual result will be parsed by the plugin, in the format accepted by
    sysdata-collector python plugins as follows:

    sample['header1'] = 'value1'
    sample['header2'] = 'value2'
    sample['header3'] = 'value3'
    """

    # Used for thread locking
    LOCK = threading.Lock()
    external_plugins_list = []

    #----------------------------------------------------------------------
    def readConfigVars(self):
        """
        Read the header_prepend_plugin_name and load_extensions (different script
        extensions to be loaded) from the configuration file
        """
        self.options = {
            'load_extensions': ['.sh', '.pl'],
            'header_prepend_plugin_name': True
        }

        Section = 'Plugin'
        if(self.config.has_section(Section)):
            VarToRead = 'load_extensions'
            if(self.config.has_option(Section, VarToRead)):
                LOG.debug("Reading value for " + VarToRead)
                self.options[VarToRead] = split_strip(self.config.get(Section, VarToRead))
                LOG.debug(VarToRead + ' = ' + str(self.options[VarToRead]))

            VarToRead = 'header_prepend_plugin_name'
            if(self.config.has_option(Section, VarToRead)):
                LOG.debug("Reading value for " + VarToRead)
                self.options[VarToRead] = self.config.getboolean(Section, VarToRead)
                LOG.debug(VarToRead + ' = ' + str(self.options[VarToRead]))

        extensions = {}
        if(os.path.exists(active_plugins_dir)):
            for extension in self.options['load_extensions']:
                if extension:
                    # Make sure the extension has a leading dot '.'
                    if extension[0] != '.':
                        extenstion = '.' + extension

                    # Make sure extension is unique until now
                    if extension not in extensions.keys():
                        # Add the extension in a dictionary key, to be able to quickly identify unique values
                        extensions[extension] = True
                        self.external_plugins_list.extend(glob.glob(active_plugins_dir + "/*" + extension))

    #----------------------------------------------------------------------
    def collect(self, prevResults = None):

        # Run the external plugins in different threads parallely to speed up execution.

        samples = OrderedDict()
        threads = {}
        try:
            for external_plugin in self.external_plugins_list:
                # Collect data from each external plugin in a separate thread
                threads[external_plugin] = threading.Thread(target=self.runCollectThreaded, args=(samples, external_plugin))
                threads[external_plugin].start()

            for external_plugin in self.external_plugins_list:
                # Wait for all of the threads to finish execution
                threads[external_plugin].join()
                del threads[external_plugin]
        except:
            traceback.print_exc()
            exit(1)

        return samples

    def runCollectThreaded(self, result, externalScriptPath):
        """
        Function ro run the collect jobs in threads.
        results:              The dictionary to store the result
        externalScriptPath:   The key in dict results to store the result
                              and the path to the external script to execute
        """

        # Execute the script
        cmd = executeCommand([externalScriptPath])

        # Check if the return code is zero (which means that the script was executed successfully)
        if (cmd.getReturnCode() != 0):
            LOG.critical("Execution return code of the external script '" + externalScriptPath + "' is '" + str(cmd.getReturnCode()) + "'")
            LOG.critical("Please check what went wrong with the script. Aborting execution.")
            thread.interrupt_main()


        # Get the basename of the script without the extension
        name = os.path.basename(os.path.splitext(externalScriptPath)[0])

        r = quick_regexp()
        for line in cmd.getStdout():
            # Each line should have two space separated values.
            # First is the header and second is the actual value
            if(r.search('(\S+)\s+(\S+)', line)):

                if self.options['header_prepend_plugin_name']:
                    # In the header, prepend the name of the script to avoid conficts
                    header = "{0}_{1}".format(name, r.groups[0])
                else:
                    header = r.groups[0]
                value = r.groups[1]

                # Acquire the Lock when accessing 'result' (which is pointing to the sample and other threads
                # will try to access it as well)
                with self.LOCK:
                    #print "'" + name + "' ('" + threading.current_thread().name + "') acquired lock"
                    # If the header exists, raise an error and exit.
                    if result.has_key(header):
                        LOG.critical("Header '" + header + "' which is generated by script '" + externalScriptPath + "' already exists!!")
                        LOG.critical("Please check that your external scripts have different basenames and/or headers. Aborting execution.")
                        thread.interrupt_main()
                    result[header] = value
